# Coding Brain Technical Architecture

A technical overview of the Coding Brain (OpenMemory fork) architecture as implemented in this repo. This document focuses on the current codebase, runtime topology, and data flows.

---

## 1. Executive Summary

Coding Brain is a multi-store memory and code-intelligence system. It exposes REST APIs and MCP tools over SSE, backed by PostgreSQL, Qdrant, OpenSearch, Neo4j, and Valkey. The system has two main planes:

- Memory plane: structured memories stored in Postgres and Qdrant, enriched with a Neo4j metadata graph.
- Code intelligence plane: indexing and CODE_* graph modules with tri-hybrid retrieval and analysis tooling.

Optional subsystems include business concept extraction and guidance via a separate MCP endpoint.

---

## 2. System Topology

```
Clients (IDE/MCP/REST)            UI (Next.js)
          |                            |
          v                            v
   FastAPI API + MCP servers  <----  openmemory/ui
          |
          |------------------------
          |   Data Stores
          |------------------------
          |  PostgreSQL  - memory metadata, users, apps, configs
          |  Qdrant      - memory embeddings, concept embeddings (optional)
          |  OpenSearch - lexical/hybrid search index for memories
          |  Neo4j       - OM_* memory graph, CODE_* code graph, concepts
          |  Valkey      - session binding, DPoP replay cache
          v
```

---

## 3. Core Services and Stores

| Component | Purpose | Code Reference |
| --- | --- | --- |
| FastAPI API | REST endpoints, MCP SSE servers, security, ops | `openmemory/api/app` |
| UI | Memory browser and test UI | `openmemory/ui` |
| PostgreSQL | Memory records, apps, configs, feedback, experiments | `openmemory/api/app/models.py` |
| Qdrant | Vector embeddings for memories and concepts | Mem0 config, `app/utils/memory.py` |
| OpenSearch | Search index for memories (lexical + vector) | `app/stores/opensearch_store.py` |
| Neo4j | Graph metadata and CODE_* graph | `app/graph`, `openmemory/api/indexing` |
| Valkey | SSE session binding and DPoP replay cache | `app/security/session_binding.py` |

---

## 4. Memory System

### 4.1 Structured Memory Schema

Structured memory metadata is validated in `app/utils/structured_memory.py`.

- Categories: decision, convention, architecture, dependency, workflow, testing, security, performance, runbook, glossary
- Scopes: session, user, team, project, org, enterprise
- Artifact types: repo, service, module, component, api, db, infra, file
- Additional fields: artifact_ref, entity, evidence, tags, source, source_app

### 4.2 Memory Ingestion Flow

```
REST or MCP
   |
   v
Structured validation
   |
   v
Mem0 client (LLM + embedder)
   |                         \
   v                          v
PostgreSQL record        Qdrant vector
   |
   v
Neo4j metadata projection (OM_*)
   |
   v
Optional similarity edges, entity bridge, tag co-occurrence
```

The Mem0 client configuration is stored in Postgres and exposed via `/api/v1/config`.

### 4.3 Neo4j Metadata Graph (OM_*)

The metadata projector builds a deterministic graph of memory metadata:

Key node labels:
- `OM_Memory`
- `OM_Entity`
- `OM_Category`, `OM_Scope`, `OM_ArtifactType`, `OM_ArtifactRef`
- `OM_Tag`, `OM_Evidence`, `OM_App`
- `OM_TemporalEvent` (biographical timeline)

Key relationships:
- `OM_ABOUT` (memory -> entity)
- `OM_IN_CATEGORY`, `OM_IN_SCOPE`
- `OM_HAS_ARTIFACT_TYPE`, `OM_REFERENCES_ARTIFACT`
- `OM_TAGGED`, `OM_HAS_EVIDENCE`, `OM_WRITTEN_VIA`
- `OM_CO_MENTIONED` (entity co-occurrence)
- `OM_RELATION` (typed entity relation)
- `OM_COOCCURS` (tag co-occurrence)
- `OM_SIMILAR` (memory similarity)
- `OM_TEMPORAL` (entity -> temporal event)

### 4.4 Mem0 Graph Bridge

If Mem0 graph memory is enabled, LLM-extracted `__Entity__` nodes and relations are bridged into OM_* edges to keep the metadata graph deterministic while still leveraging Mem0 extraction.

### 4.5 Similarity Projection

Similarity edges (`OM_SIMILAR`) are generated by querying Qdrant for nearest neighbors and projecting them to Neo4j.

---

## 5. Search and Retrieval

### 5.1 MCP Memory Search

The MCP search tool uses Mem0 vector search and then re-ranks using metadata and graph signals (`app/utils/reranking.py`).

The `search_memory` tool supports a `relation_detail` parameter to control output verbosity:

- `none`: No meta_relations (minimal tokens)
- `minimal`: Only artifact + similar IDs
- `standard`: + entities + tags + evidence (default, ~60% token reduction vs full)
- `full`: Verbose format with all OM_* relations

### 5.2 Memory Retrieval and Metadata Sync

The `get_memory` tool retrieves a single memory by UUID with all fields including `access_entity`.
A Qdrant `set_payload` method enables metadata-only updates without altering vectors, and a
backfill script (`app/scripts/backfill_qdrant_metadata.py`) synchronizes metadata from PostgreSQL to Qdrant.

### 5.3 Code References in Memories

Memories can link to source code via the `code_refs` parameter in `add_memories`:

```python
code_refs=[{"file_path": "/src/auth.ts", "line_start": 42, "line_end": 55}]
```

Code references are serialized into tags for retrieval and display.

### 5.4 REST Search (OpenSearch)

The REST search endpoints use a tenant-scoped OpenSearch store:
- Aliases isolate data per `org_id`.
- `/api/v1/search` is lexical-only today (no on-the-fly embeddings).
- `/api/v1/search/semantic` supports vector search when a `query_vector` is provided.

---

## 6. Business Concepts (Optional)

Business concepts are feature-flagged and use a separate MCP endpoint.

- Enable via `BUSINESS_CONCEPTS_ENABLED=true`.
- Concepts are extracted with an LLM and stored in Neo4j as `OM_Concept` and `OM_BizEntity` nodes.
- Optional vector embeddings are stored in Qdrant collection `business_concepts`.
- MCP SSE endpoint: `/concepts/<client>/sse/<user_id>`

---

## 7. Code Intelligence Plane

### 7.1 Indexing Pipeline

The indexing modules provide:
- Tree-sitter AST parsing for Python, TypeScript/TSX, and Java
- SCIP symbol ID normalization
- CODE_* graph projection + OpenSearch document indexing
- API boundary detection for REST client/server links
- NestJS/Angular decorator extraction (60+ decorators mapped in KNOWN_DECORATORS)
- Event registry for publisher/subscriber discovery
- Merkle tree and bootstrap/priority queue modules exist but are not wired into the indexer yet

Primary modules:

- `openmemory/api/indexing/ast_parser.py` - includes decorator extraction
- `openmemory/api/indexing/scip_symbols.py`
- `openmemory/api/indexing/graph_projection.py`
- `openmemory/api/indexing/api_boundaries.py`
- `openmemory/api/indexing/event_registry.py` - publisher/subscriber management

### 7.2 CODE_* Graph Schema

Core node labels:
- `CODE_FILE`
- `CODE_SYMBOL`
- `CODE_PACKAGE`
- `CODE_APIEndpoint`
- `CODE_APIClient`

Core edge types:

- `CONTAINS`, `DEFINES`, `IMPORTS`, `CALLS`, `READS`, `WRITES`, `DATA_FLOWS_TO`
- `EXPOSES` (handler -> API endpoint)
- `CONSUMES` (client -> API endpoint)
- `TRIGGERS_EVENT` (publisher -> event -> subscriber)

### 7.3 Tri-Hybrid Retrieval

Tri-hybrid retrieval combines:
- Lexical search (OpenSearch BM25)
- Vector search (OpenSearch kNN)
- Graph context from the CODE_* graph

Default weighting in `TriHybridConfig`:
- vector: 0.40
- lexical: 0.35
- graph: 0.25

RRF-style fusion is supported as an alternative strategy. A reranker module provides cross-encoder, Cohere, or no-op adapters.
Reranking helpers exist in `openmemory/api/retrieval/reranker.py` but are not wired into REST/MCP yet.

### 7.4 Code Intelligence Tools

REST exposes `/api/v1/code` endpoints for search, explain, callers/callees, impact analysis,
ADR automation, test generation, PR analysis, and indexing. MCP exposes index/search/explain
plus callers/callees/impact. Other tool modules (e.g., symbol definition) remain library-only.

### 7.5 Tool Fallback Cascade

The `find_callers` tool includes a 4-stage fallback cascade to prevent AI hallucination
when symbols are not found in the graph:

1. **Graph Search (SCIP)** - Primary call graph traversal
2. **Grep Fallback** - Pattern matching for symbol name
3. **Semantic Search** - search_code_hybrid with keywords
4. **Structured Error** - Returns suggestions and next actions

When results come from a fallback stage, ResponseMeta includes `degraded_mode`, `fallback_stage`,
`fallback_strategy`, and `suggestions` fields.

### 7.6 Visualization and Cross-Repo Utilities

- Graph export to JSON, DOT, and Mermaid (`openmemory/api/visualization`)
- Cross-repo registry, dependency graph, and unified search (`openmemory/api/cross_repo`)

---

## 8. API and MCP Surface

### REST
Key routers under `/api/v1`:
- memories, apps, stats, config
- search, graph, entities, code
- feedback, experiments
- backup, gdpr

### MCP
- Memory MCP: `/mcp/<client>/sse/<user_id>`
- Business Concepts MCP: `/concepts/<client>/sse/<user_id>`
- Guidance MCP: `/guidance/<client>/sse/<user_id>`

---

## 9. Security and Session Binding

- JWT validation with issuer, audience, and scope checks
- Optional DPoP token binding with Valkey replay cache
- SSE session binding to prevent hijacking
- Scope enforcement via `app/security/types.py`

---

## 10. Observability and Resilience

- Health endpoints: `/health/live`, `/health/ready`, `/health/deps`, `/mcp/health`
- Circuit breaker utilities for external dependencies
- Rate limiting middleware (available but not mounted by default)
- Audit logging for security-sensitive operations
- Prometheus metrics endpoint at `/metrics` plus OpenTelemetry tracing hooks

---

## 11. Configuration and Feature Flags

### Required secrets (see `openmemory/.env.example`)
- `JWT_SECRET_KEY`
- `POSTGRES_PASSWORD`
- `NEO4J_PASSWORD`
- `OPENAI_API_KEY`
- `OPENSEARCH_INITIAL_ADMIN_PASSWORD`

### Feature flags
- `BUSINESS_CONCEPTS_ENABLED`
- `BUSINESS_CONCEPTS_AUTO_EXTRACT`
- `BUSINESS_CONCEPTS_EMBEDDING_ENABLED`

### Mem0 configuration
- Stored in Postgres, managed via `/api/v1/config`
- Supports LLM, embedder, vector store, and graph store configuration

---

## 12. Deployment Defaults

From `openmemory/docker-compose.yml`:
- API/MCP: `http://localhost:8865` (container port 8765)
- UI: `http://localhost:3433`
- Docs: `http://localhost:3080/docs/`
- PostgreSQL: `localhost:5532`
- Valkey: `localhost:6479`
- Qdrant: `localhost:6433` (gRPC 6434)
- Neo4j Browser: `http://localhost:7574` (Bolt 7787)
- OpenSearch: `http://localhost:9200`

---

## 13. Graceful Degradation

Graph and search operations are designed to fail gracefully:
- If Neo4j is unavailable, graph operations return empty results and do not block memory CRUD.
- If OpenSearch is unavailable, REST search returns empty results or 503 responses.
- If Qdrant is unavailable, Mem0 can fall back to database-only mode for memory storage.
